---
layout: post
title:  "마법같은 멋진 방법은 없다. 일단 구현을 하자!"
date:   2019-03-03 21:00:00 +0900
cover:  "/assets/netty.jpeg"
categories: [blog]
author: Mocha
---

대학 재학 중 과제와 프로젝트를 진행하면서 코딩/개발을 하면서 느낀점은 '내가 작성한 것이 과연 정답일까? 분명 더 판타스틱하고 좋은 방법이 있을텐데... 내 방식은 뭔가 엉성해! 하지만 당장 제출을 위해 보유한 기술로 요구사항을 충족해야겠어' 라는 생각을 하며 항상 불만족스러운 코딩을 한적이 많다. 그리고 회사에 들어가면 내가 작성하던 코드보다 훨씬 수준이 높고 고도화된 기술을 사용하여 일을 할것이다 라고 생각하고 있었다.

반은 맞고 반은 틀린 생각인듯하다. 회사에 들어가서 확인해보니 환상을 가졌던 판타스틱한 방법은 없었고 단순한 방식만이 있었을 뿐이다. 하지만 아무 생각없이 단순한 방식을 사용 하는 것과 깊이 고민 끝에 나온 단순한 방식은 완전히 다르다 라는 사실을 명심해야한다. '깊은 고민 끝에 나온 단순한 방식' 이 아마도 기대했었어야하는(should have expected) 판타스틱한 방식일 것이다.

## 내가 생각한 수준 높음의 정도
대학생때 내가 생각한 수준 높음이란, 복잡한 기능을 구현하기위해 `if-else` 나 `for 루프` 가 덕지덕지 붙은 코드가 아닌 필요한 라이브러리를 적절하게 사용하여 한두줄의 코드로 구현하는 것을 생각했던거같다. 그리하여 소프트웨어공학 수업의 학기 과제였던 '배달 음식 주문 시스템' 프로젝트를 진행하면서 내가 구현했던 방식들이 유치하다고 생각들었다. CLI환경에서 유저 UI를 만들었어야했는데, UI를 위해 주로 아래와 같은 방식으로 코딩을 했기 때문이다.

{% gist 31884328c5d050ff0084d6178e12e1cd %}

위 코드에서 불만족스러웠던점은 
1. 유저 메뉴를 노가다성 String과 cout으로 구현한 점
2. 메뉴 선택을 cin으로 stdin 입력으로 받아 처리한 점
이었다(지금 생각해보면 별 방도가 없는게 당연한데 저땐 내가 구현한 방식이 구닥다리라 생각들었다). 

구현방식에 환상을 가지고 있던 라이브러리 중 하나는 프로세스의 진행도를 표시해주는 라이브러리인 `progress bar`가 있다. 이 라이브러리는 엘레강스한(?) 구현으로 prgress bar를 그려줬을거라 생각했다. 무엇보다 이미 터미널에 stdout으로 출력된 문자열을 업데이트 한다는 점이 나에겐 마법이었다.

```bash
100% (10 of 10) |###############################################################| Elapsed Time: 0:00:00 Time:  0:00:00
```

만약 당장 구현한다면, progress bar 클래스를 만든 뒤 클래스에는 진행 상태를 관리하면 변수 하나를 만들고, 상태를 update를 할 수 있는 함수와 진행도를 문자열로 출력하는 함수를 뚫어 사용자에게 제공해줄거같다. 하지만 이미 출력된 문자열에 변화를 주는 것은 어떻게 구현해야하는지 감조차오지 않았다.

```python
class MyProgressBar():
	# variable
	# Max.status = 10
	# min.status = 0

	def __init__(self):
		self.status = 0
		self.finishedList = [' ']*10

	def update(self, status):
		self.status = status
		for i in xrange(status):
			self.finishedList[i] = '#'

	def printProgress(self):
		print '{}%\t|{}|'.format(self.status*10, ''.join(self.finishedList))
```

실제로 디버깅을 돌려보면서 구현되어 있는 코드를 보니 내가 생각한 방식대로 구현되어있었다(다만, 객체들이 mixin 형태로 나누어져있어서 파악하긴 힘들었다).

## 마법은 없다.
위 예시였던 `progress bar`와 같이 모든 라이브러리/프레임워크 엔 마법이 없을 것이다. 다만, print와 같이 내 프로세스에서 활용할 수 있는 system call의 적절한 활용과 잘못된 사용으로 에러가 발생하지 않게끔 방어처리 되어 있을것이다. 더욱이 내가 마법이라고 생각한 '이미 출력된 문자열의 업데이트' 는 마법이 아닌 인간(?)이 할 수 있는 방법으로 구현되어 있었다.

1. stdout 커서를 첫 열로 이동시켜('/r')
2. 빈 문자열로 채운 뒤 stdout으로 출력해주고 (기존 출력된 문자열 삭제)
3. 새로 업데이트된 진행도 를 stdout으로 출력해주는 것이었다.

위 3개 단계가 너무 순식간에 지나가기 때문에 나에게 있어 마치 터미널에 출력된 문자열이 실시간으로 업데이트 되는거처럼 보였다.

```python
def update(self, value=None):
    self.fd.write('\r' + ' ' * self.term_width + '\r')      # Step 1
    utils.streams.flush()                                   # Step 2
    DefaultFdMixin.update(self, value=value)                # Step 3
```

나아가 라이브러리/프레임워크의 코어 코드에는 시스템 엔지니어가 아닌 개발자가 몰라도 되는 부분이 구현되어 있기 때문에 시스템을 잘 모르는 사람이 소스를 들여다보면 이해하기 난해할 수 도 있다.


## 사례: command line flag 처리
서버같은 데몬 프로세스가 아닌 client와 같은 batch 성격의 프로그램들은 실행시 옵션을 주어 각기 다른 동작을 하게 만들수 있다. 예를 들면 `ls` 명령어에 `--all, -l' 과 같이 flag 옵션을 주어 실행시킬 수 있다.

이 또한 구현하는 코드엔 특별한 마법이 있으리.. 생각했지만 프로세스 실행시 인자값(argv[1..n])을 모두 확인하여 문자열 가장 앞 character가 '-' 인지 확인하고 그 다음 character가 코드에 정의된 옵션인지까지 확인한 뒤 각 옵션을 세팅할 수 있게 구현되어있는것을 확인하였다.

물론 요즘 Golang에서는 [flag](https://golang.org/pkg/flag/) 라는 package를 활용하여 쉽게 구현할 수 있다. 하지만 이 패키지의 내부를 까보면 위 방식을 사용하고 있겠지만, 확장가능하고 에러에 내성을 가진 형태로 구현되어 있을것이다.

## 사례: springboot app 구동 스크립트
'그래도 서비스를 전문으로 회사인데 java 명령어로 돌리지 않겠지' 라는 잘못된(?) 생각을 가지고 있었다. 참고로 난 대학교에서 웹서버 하번 만들어보지않고 배치 프로그램만 만들어본 신입 개발자였다. 그렇기에 당장 데몬프로세스를 띄우라고하면 bash 명령어인 

`nohub java ... &` 

을 이용하여 데몬 프로세스를 띄웠을것이고, 종료하기위해서는 `ps` 명령어로 pid를 확인한 뒤 `kill <pid>`로 종료했을 것이다.

(이제쯤 예상하겠지만) 이 또한 스프링부트 구동 스크립트에서 똑같이 사용하는 방식이었다. 다른 점은 에러 내성적으로 스크립트를 구현했기 때문에
1. 이미 데몬이 돌고있으면 또다른 데몬이 돌지않게끔 처리 되어 있고
2. 실제 프로세스가 없을 경우 종료를 시도할 때 에러를 출력해줄 수 있는 형태로 
구현되어있다.


