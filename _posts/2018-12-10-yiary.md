---
layout: post
title: "mocha의 2017, 2018 회고록"
date: 2019-01-27 +0900
# permalink: 2017-2018-yairy
categories: [blog]
cover:  "/assets/instacode.png"
author: Mocha
---

# 쓰기 전에... (내가)
원래는 2017년 한해를 마무리 하며 하나를 써야했지만 선천적인 게으름(<- 개발 잘하는 사람들 오마주)때문에 2017,2018년 회고록을 이제야 작성한다.

평생 회고록이라는걸 모르고 살다가 회고록을 쓰게된 이유는... 10월쯤 술김에 이거써야지 저거써야지 주제를 정해서 facebook에 타임라인으로 남겼다. 그리고 12월쯤 쓰는김에 요즘(?) 핫하다는 github page를 활용하여 써보자 마음먹고, q='github page 만드는법' 을 검색하여 여러 가이드 글을 본 뒤 감을 잡고 하나하나 써내려걌다. 

주제를 선정할 땐 나름 기준을 두었는데 자랑스럽게 쓰고싶은 주제, 그리고 차마 내 실력이 들통날까봐 숨기고 싶은 주제를 선정하였다.

이 글을 통해 '아! 이정도면 나도 회고록 쓸 수 있겠다' 라는 생각이 드는 사람들이 많아졌으면 좋겠다.

# 커뮤니케이션/나홀로고민의 트레이드오프
## 이 주제를 선택한 이유
1년반 동안 일하면서 개발은 무엇인가를 한마디로 설명하자면 **개발 = 코딩 * 커뮤니케이션** 이라는 사실이다. 주변 취업한 선배 또는 소프트웨어 공학 교수님께 귀에 피가 나도록 들었을 말이다. 하지만 도대체 왜 커뮤니케이션이 중요한지에 대한 설명과 그 예시 사례에 대해서는 구체적으로 말해주는 사람은 없었을 것이다. 1년반 동안 일하면서 왜 커뮤니케이션이 중요한지에 대한 내 생각과 어떤 사례가 있었는지를 이 회고록에 적어보겠다.

## 커뮤니케이션이 중요한 이유
개발에서의 커뮤니케이션을 논하기 전 학교에서 배웠던 소프트웨어 개발을 되짚어보자.

 ---------- 
> 1. 요구사항 파악
> 2. 설계
> 3. 구현
> 4. 테스팅
> 5. 출시(배포)

----------
 
정말 교과서적인 방법이다. 만약 실제 개발에서도 위 방식이 무리없이 진행된다면 우리 모두 행복(?)하게 개발할 것이다. 하지만 저 과정을 소화하는 것은 무척이나 힘들다. 저 과정을 온전히 진행하기 위해 커뮤니케이션은 필수적이고 어떤 방식으로 커뮤니케이션을 해야하는지에해서는 책에서는 언급을 해주지않기 때문이다. 

## 서비스 개발에서의 커뮤니케이션
다른 도메인에선 어찌 개발을 하는지 모르지만 최소한 서비스 개발에선 커뮤니케이션이 50%를 차지한다고 생각한다. 왜 커뮤니케이션이 50%나 차지하는 것일까?? 결론부터 말하자면 커뮤니케이션 없이 개발도 못하기 때문이다.

`만약 커뮤니케이션 없이 일한다면` 서비스 기획 문서, 연동 API 문서, 기존 서비스 레거시 문서 등을 찾는데 시간을 쏟으면서 하루면 끝낼 **일을 일주일 내내 붙잡고 있거나** 내 API를 연동해가는 조직에서 '이걸 이상하게 사용하면 어쩌지...' 라는 쓸데없는 걱정으로 **극도의 방어적 프로그래밍**을 하느라 처음에 잡아놓은 구현 일정을 Over하게 될 것이다. 이런 일들이 지속되게 되면 주변사람들에게 평판을 잃게 되고 평판을 잃으면 `개발을 잘하지 못한다` 라는 인식이 생긴다. 그로인해 아무도 같이 일을 하려 하지않을거고 천덕꾸러기 신세를 지게 될것이다.

하지만 반대로 `만약 커뮤니케이션을 잘 활용하여 일한다면` 1)서비스 기획의 전체적인 아이디어를 들을 수 있고 2)연동하는 API에서 내 서비스에 필요한 기능을 추가해달라고 요청할 수 있고 3)기존 서비스의 히스토리(사연)을 듣고 똑같은 실수를 하지 않을 수 있다. 더욱이 커뮤니케이션을 통해 얻은 지식을 기반으로 문서를 보고 빠르게 핵심을 캐치할 수 있다.
그만큼 개발자에게 있어서 커뮤니케이션은 중요한 요소이다. 실제 개발 포지션의 면접자리에서도 최소한의 커뮤니케이션 능력이 있는지 검증을 하는 듯하다. 이때 보려는 커뮤니케이션 능력은 거창한 것이 아니라 **상대 생각을 캐낼 수 있는 능력(Request)**, **본인이 아는 것을 말할 수 있는 능력(Response)** 정도이다. 선척적으로 타고난 사람들도 있지만 나에게 있어서는 지난 1년반동안 챌린져블한 일이 었다(지금은 훈련끝에 보통 수준으로 할 수 있게 된거같다). 그렇다면 *Request*와 *Response*는 도대체 어떤 능력일까? 사례를 통해 느껴볼 수 있다.

사례는 2가지가 있는데 하나는 **단방향 커뮤니케이션** 이고, 또 다른 한가지는 **양방향 커뮤니케이션** 이다.

단방향 커뮤니케이션은 토론을 하거나 협업을 위한 커뮤니케이션이 아니라 지식이 단방향으로 흐르는 커뮤니케이션이다. 대부분의 주니어들이 첫 1~2년간은 주로 하게될 커뮤니케이션이다. 회사에 들어온지 얼마안되는 주니어들은 사내 개발프로세스, 도메인 지식, 자주 사용하게될 용어, 맡게될 업무의 히스토리 등을 파악해야 할 것이다. 이때, 타고난 사람이라면 기획문서/소스코드만 보고 모든걸 파악하여 업무를 따라 갈 수 있을 것이다. 전제는 모든 문서와 소스코드는 논리적이어야 한다(문서/소스코드 부터가 논리적이지않다면 부처님 할아버지가 와도 파악하지 못할 것이다). 하지만 모든 문서가 논리적으로 쓰여진 것도 아니고 자신 타고난게 아니라면, 빠르게 포기하고 보통 사람이 `타고난 것처럼 보일 수 있는 전략`을 써야한다. 타고난 것처럼 보일 수 있는 전략은 **커뮤니케이션**이다. 

이때 *Request*가 좋아야 본인의 사수나 주변 사람들에게 좋은 *Response*를 받을 확률이 커진다. 거꾸로 말하면 *Request*가 좋다고 무조건 *Response*가 좋은 것인 아니다. 그 이유는 나 스스로 *Request*가 좋했지만 상대방 입장에선 나의 *Request*가 그지같을 수 있기 때문이다. 좋은 *Response*가 나왔을 때 비로소 좋은 *Request*다 라고 생각하면 편하다.

나의 경우 2017년에는 **단방향 커뮤니케이션**을 잘 하지 못했다고 생각한다. *Request*를 잘 시도하지 않았기 때문이다. 나 편하자고 상대방의 시간을 할애하는 것이 미안했기 때문이다. 하지만 혼자서 끙끙 앓으며 허송세월 시간을 보내는 것을 생각해보면 회사에 더욱 미안한 일이 될 것이다. 그리고 나의 이런 성향을 고쳐나가려 했고 지금은 많이 바뀌었다고 생각한다. 

**양방향 커뮤니케이션**은 다른 조직과 API 프로토콜을 맞추거나 기획자와 함께 서비스 개발/개편을 할때 하게 될 커뮤니케이션이다. 단방향 커뮤니케이션과 달리 양방향 커뮤니케이션은 말그대로 양쪽 모두 지식이 흐르는 커뮤니케이션이고 최종 목적은 상대방의 지식과 나의 지식을 결합하여 적절한 합의점을 찾는 것이다. 예를 들어 상대방이 나의 API 연동해가고 있는 상황에서 

여기에서도 서로의 생각을 솔직하게 오픈해야하는데 내가 확실히 해낼 수 있는 일을 말해주고 상대방의 말이 이해가 되지않는다면 끊임없이 질문을 해야한다. 그래야 적은 횟수의 커뮤니케이션으로 일을 진행할 수 있기 때문이다. 만약 지레짐작으로 상대의 의도를 추측하고 논의를 끝낸다면 결국엔 똑같은 커뮤니케이션을 한번 더 하게된다. 따라서 한번 커뮤니케이션을 할때에는 확실히 알고 가야하며, 나또한 상대방이 확실히 알고가게 하기위해 솔직한 내 상황과 한계점을 말해주어야한다.

만약 서로 알고있는 용어(term)가 일치한다면 양방향 커뮤니케이션은 훨씬 수월해질 수 있다. 용어를 잘 사용하면 문장을 줄여줄 수 있고, 문장이 줄어들면 상대방은 내 의도를 파악하기 쉽다. 하지만 용어를 잘못 사용한다면 커뮤니케이션에 있어 오해가 발생할 수 있고 불필요한 개발리소스(시간, 스트레스 등) 낭비를 초래할 수 있다. 업무 진행 전 서로 사용하는 용어가 잘못된것을 알아차리면 다시 논의를 진행 할 수 있지만(compiletime error), 업무를 진행하던 중 용어가 잘못되어 다시 논의를 시작해야하는 경우는(runtime error) 상상하기 싫을 정도이다. 

> 사례: 대부분의 웹서비스는 유저들이 배포 사실을 못느끼게 하기 위해 여러 대의 서버를 순차적으로 접근하여 배포를 진행한다. 이러한 배포를 무중단 서비스 배포라고 하고 무중단 배포를 위해 주로 사용하는 기법은 health check를 이용한 rolling restart 방식이다. 

여기서 나온 용어는 총 3가지가 있는데, '무중단 서비스', 'healthcheck', 'rolling restart(rr)' 이 있다. 만약 이 용어가 없었다면 나는 10줄 이상의 문장을 만들어 써야할 것이다. 또한 내가 잘못된 용어를 사용했다면 읽는 사람은 '무슨 이야기를 하는거지?' 라면서 나에게 되물어볼 것이고 나는 또 10줄 이상의 추가 문장을 만들어야한다.

# High Invest, Low Return
## 이 주제를 선택한 이유
역량 성장을 위해 투자한 시간이 모두 보상으로 돌아온 것은 아니었다. 나의 경우 지난 1년반 동안 투자한 시간에 대한 보상이 기대한 수준의 10% 정도만을 얻었다고 생각한다. 지금 생각해보면 10%씩이나 리턴으로 얻은걸 감사히 생각한다. 주니어 시절에는 실제 개발에서 만나게되는 컴퓨터 지식, 개발툴 스킬, 프로그래밍언어 등의 분야에서 성장하는 요령이 없기 때문에 노력한 시간에 비해 낮은 성과를 달성하는 것은 당연한 것이고 처음부터 100% 리턴을 모두 얻으려는 욕심은 한술에 배부르기와 같지 않을까 생각들었다. 그간 내가 어떤 삽질들을 했었고 어떻게 덜 삽질하하려고 개선해나갔는지와 배우는 요령에 대한 이야기로 이 주제를 정리하겠다.

## 직접 써봐와 그나마 Return이 돌아온다
개발을 잘하(는척하)고 싶어 남들이 좋다고 말하는 기술/툴을 배우려고 한적이 있다. 2015년도 쯤 꽤 핫 했던 Rest API, Git이 있었는데 나는 이것들을 우선적으로 정복하기로 했다(요즘엔 Docker, Elastic Search 등이 핫 한거같다). Git이 왜 유행인지 모르는 상태로 일단 많은 사람들이 좋다고 하니 뭔진 모르겠지만 배워보자! 마음먹고 Git은 무엇인지 부터 찾아봤다. 

구글에 `what is git?` 이라고 검색하여 1등으로 뜨는 문서를 보니 버전관리시스템(Version Control System)이라고 하더라. 왜 소스코드의 버전을 관리해야하는지에 대한 이유는 관심밖에 둔채 그냥 좋다고하니 배워보자 마음먹고 Git 공식 문서를 보면서 제대로 익혀보기로 했다. 참고로 나는 대학교 시절 소스코드를 날짜별 디렉터리로 관리했던 경험이 있다. 주로 Dropbox라는 서비스를 활용하여 교수님과 함께 작업을 하였는데 Git이 이런 비슷한 일을 알아서 해주는것인가? 생각들었다.

Git 공식문서 중 [Git 기초][IntroGit]를 이해하는 것이 가장 큰 난관이었다. 지금의 나의 입장로서는 문서의 설명이 자연스럽지만 Git 개념을 처음 접하는 나로서는 문서에 나온 설명들이 난해하고 뜬구름 잡기처럼 느껴졌었다. 특히 왜 브랜치라는 것이 있고, 왜 staging이라는 단계가 있고, (git과 관련은 없지만) 도대체 왜 github에서는 Drag&Drop이 안되는지에 대한 것이 제일 큰 벽이었다. 마치 프로그래밍을 처음 입문하는 사람이 포인터 개념을 배울때의 느낌이랄까? 그렇게 공식문서를 보는데에만 시간을 쏟은 나는 git에 대해 제대로 익히지 못하고 나의 큰(?) 결심은 쉽게 좌초되었다.

그러던 중 첫 직장에서 일하기 시작하면서 git을 사용하기 시작하였고 공식문서를 통해 배우기보다는 (파트내 git을 도입한) 옆자리 선배가 git clone은 어떻게 하는 것인지, 브랜치는 어떻게 따는지, 커밋은 어떻게 하는지에 대해 친절히 설명해주었다. 그리고 나는 배운대로 무작정 따라하기 시작하였다. 배운 기능을 적극활용하여 활용하여 내가 맡은 업무에 휴먼에러가 없게끔, 그리고 변경 이력을 남길 수 있게 git을 사용하려고 노력하였고 계속 사용을 하다보니 Git 개념이 이숙해지기 시작하였다. 그리고 다시 공식문서를 봤을때는 '이렇게 밖에 설명할 수 없겠구나' 라고 생각들었다. 마치 '실해석학개론'을 배울때 함수의 연속성을 정의하기 위해 왜 입실론-델타 사용할 수 밖에없는지를 이해했던 것과 비슷하다고 생각들었다. 입실론-델타 정의 외에 더 간결하고 무결한 정의가 나오지 않았기 때문이다. Git 문서 또한 이렇게 밖에 설명할 수 없다고 생각한다. 하지만 여전히 왜 브랜치 개념이 버전 관리에 편리함을 주는지는 이해하지 못하였다.

Git 브랜치 기능의 편리한 점을 제대로 이해한 것은 지금의 회사에서 일하면서부터이다. 서비스 코드를 배포할때 나의 사수와 나는 [git flow][gitFlow] 개념을 적극 활용하기로 하였다. 그 중 제일 편리하게 사용했던 경험은 여러개의 feature를 통합테스트에 적용할 때이다. 아래는 그 사례이다.

> 사례: (모든 회사들이 그렇겠지만) 나의 조직에서는 코드를 수정하면 적당한 유닛테스트를 한 뒤 테스트 서버에 배포하여 통합테스트를 진행한다. 이 때 주로 다른 서비스와의 충돌로 인한 사이드이펙트가 존재하는지 확인한다. 급하지 않은 일정이라면 기획자&관련 개발자와 함께 일주일 정도 통합테스트를 진행한 뒤 실서비스에 배포를 진행한다. 한번은 동시에 3개의 feature를 적용하여 테스트 서버에 배포 후 테스트를 하고있는데, 특정 feature 1개를 제외하고 다시 테스트 서버에 배포해달라는 요청을 받은 적이 있다. 만약 develop 브랜치 하나에서 3개의 기능을 모두 추가/수정 하였다면 나는 멘붕에 빠졌을 것이다. 하지만 다행히 나는 feature 마다 각각의 브랜치를 따서 기능 개발을 하였고 develop 브랜치에 각각을 merge한 뒤 테스트 서버에 배포하였다. 덕분에 나는 develop을 과거로 롤백한 뒤 2개 feature만 merge하여 다시 테스트 서버에 배포하였다. 

위 사례에서 볼 수 있듯이 git을 배우기 위해 처음부터 공식문서부터 완벽히 이해하려고 시도했고 문서를 이해하려고 들인 시간을 생각해보면 아무런 성과는 얻지 못하였다. 하지만 맡은 업무에서 git의 기능을 하나 하나 사용하다보니 (내 마음속에서 정의 할 순 없지만) git이 무엇을 해주고 내부적으롤 어떻게 돌아가는건지 알게되었다. 그렇게 감을 잡고 난 뒤 공식문서를 봤을땐 내가 왜 이 개념들을 이해하지 못했을까 생각들었고 처음부터 써보고 공식문서를 봤다면 효율적으로 기술을 습득할 수 있었겠다라는 생각들었다.

> ++ [Git 기초][IntroGit]을 보면 다른 버전관리시스템은 파일의 변경분(delta)만을 저장하여 관리하는 반면에 Git은 변경된 파일의 스냅샷을 저장하여 관리한다고 한다. 처음 이걸 들었을때 왜 굳이 변경된 파일 전체를 따로 저장하여 관리하지? 변경분만 저장 관리하는게 효율적이지 않나? 라는 의문을 가졌는데 시니어 개발자분께서 스냅샷 관리의 장점을 명쾌하게 설명해주셨다. 만약 변경분만을 저장하여 관리한다면 특정 브랜치로 이동하기 위해 처음 브랜치가 따진 commit으로 롤백해야하는데 이때 delta를 순차적으로 되감기 해줘야한다. 그리고 또 다시 해당 브랜치의 최신 commit으로 이동하기 위해 순차적으로 delta를 적용해줘야한다. 이런 동작은 cpu에 부담이 될 수 있고 무엇보다 git 소스코드가 복잡해질 수 있다. 차라리 공간을 더 쓰더라도 변경된 파일을 스냅샷으로 들고있으면 특정 commit, 특정 브랜치로의 랜덤 Access가 가능해지고 git 소스 자체도 상대적으로 간결(?)해 질 수 있다.

> +++ 추후 사내 교육을 통해 들은 이야기지만 github의 `Fork` 기능으로 인해 오픈 소스 생태계가 복잡해졌다고한다. 예를 들면 mysqlDB 레파지토리를 fork떠와서 mariaDB가 탄생하였고, 올챙이 프로젝트가 Fork되어 개구리 프로젝트가 탄생하였다고 한다. 

## 개발 중 삼천포로 빠지던 경험
인터넷이나 사람들에게 이야기로만 들었던 기술(Spring, Maven, Zookeeper, Redis 등)들을 직접 사용하며 개발을 해보면서 내부적으로 궁금한것들이 매우 많았다. 특히 내가 맡은 검색데이터 연동 프로그램은 Maven으로 빌드하는데, maven 빌드 설정파일인 pom.xml 내용이 너무 궁금하였다. 그러다보니 코드의 비지니스를 파악하기 보다는 maven 공식문서에 눈이 가기 시작했다. 때문에 나에게 맡겨진 개발을 하다 말고 이건 뭐지? 찾아보고 또 이건 뭐지 찾아보다 또 다시 돌아오고... 를 반복했었다. 이렇게 내가 자주 삼천포로 빠지다보니 정해놓은 일정을 넘기기 일쑤였다. 다행히 사활이 걸린 업무가 아니었기때문에 업무에 큰 지장은 없었지만 일을 함에 있어서 잘못된 버릇이라 생각들어 업무에 완전히 익숙해질때까진 **회사에선 비지니스만을 고민, 집에선 기술만을 고민** 하기로 하였다. 이 결론은 나를 대상으로 실험한 결과와 주변 조언을 듣고 결정되었다. 

내가 회사에 오래동안 남아 있는 이유를 분석해보니 일을 빠르게 처리하지 못해 오래 남아있는 것이었고, 일을 빨리 처리하지 못한 이유는 적절한 도구(기술)을 몰라서라고 판단하였다. 그래서 약 2주일 간 정시퇴근을 하며 집에서 기술을 공부하려해보았다. 처음 일주일간은 무조건 7시퇴근을 하면서 집에서 이것저것 알아보고 공부했다. 하지만 그 다음 일주일을 시작하는 월요일에 하루만 쉴까? 라는 생각으로 일주일 내내 집에서 유튜브나 넷플릭스만 보는 내 모습을 보았다. 그리하여 내 케이스에서는 업무에 90%이상 익숙해지기 전에 **회사에선 비지니스만을 고민, 집에선 기술만을 고민** 을 해야겠다고 다짐했다. 기술을 잘 알더라도 내가 맡은 비지니스 핵심을 꿰뚫고 있으면 간단한 기술로도 충분히 빠르게 처리할 것이라 생각했기 때문이다. 현재 이 실험을 진행중이며 2019년 회고록에서 어떤 결과가 있었는지 다시 작성을 해보겠다.

# 리더를 안심시키지못한점
## 이 주제를 선택한 이유
이 주제는 비단 개발자 뿐만 아니라 대부분의 직종에서 적용될만한 이야기라 생각한다. 리더에게 신뢰를 얻기 위해 현재 내 위치에서는 어떤 일을 해야할까? 에 대한 고민이다. 내가 가장 못했던 부분을 다루는 주제이며 1년반동안 어떤식으로 리더에게 신뢰를 얻어야할지 에 대한 고민을 적은 내용이다.

## 리더에게 신뢰를 얻어야 재밌는 일들을 한다.
학교를 벗어나 사회생활을 해보니 리더의 입장에서는 도전적이고 진취적인 결정을 하기 힘들다는 사실을 알았다. 같이 일해본 경험이 적은 팀원이 아무리 '자신있다, 해낼 수 있다'고 하여도 객관적인 사실로 봤을때 정말 해낼 수 있는지 또는 실패할 경우 어느 정도의 일정연기가 될지 모르는 상태에서 일을 맡길 수 없기 때문에 팀원의 포부만 보고 도박을 할 수 없기 때문이다. 학교 선배 정도의 위치라면 '그래 잘해봐 열심히 하니 할 수 있을거야' 라는 기준으로 역할을 맡길 순 있어도 리더급의 입장에서는 객관적인 사실로 평가하여 업무를 할당할 수 밖에 없다. 

그리하여 내가 잘해낼 수 있고 높은 성과로 돌아오는 일로 만들어낼 수 있다고 말하여도 리더 입장에서는 예측 가능한 방향으로 업무를 할당해야한다. 그도 그럴것이 모든 책임을 지는 리더입장에서는 비교적 낮은 성과의 일이더라도 90% 이상의 확률로 예측가능한 일을 진행하고싶어할 것이고, 설사 업무 할당에 실패를 하더라도 리더 본인이 예측가능한 일로 구성했기 때문에 그 다음 업무를 진행할때 참고삼아 더 좋은 방향으로 나아갈 수 있기 때문이다. 따라서 재밌어보이는 업무는 리더에게 요청하여 할당받는 것이 아니라 리더에게 믿음을 준 뒤 리더에게 예측가능하다는 사실을 보여주면 알아서 재밌는 일들을 할당받을 수 있다. 그렇다면 리더에게 신뢰를 받기 위해 어떤 행동을 해야할까?

주니어인 내 입장에서는 리더가 시키는 일을 덜도 말고 더도 말고 시킨대로 하는것이 리더에게 신뢰를 얻을 수 있는 방법이라는 결론을 얻었다. 그 중 가장 인상깊게 봤던 자료는 Naver D2에서 발표한 [넥슨 부본부장님의 강연][naverd2Nexon]이었다. 동영상에서 말하는 것처럼 처음 업무를 할당받았을땐 정말 그 기대치 만큼만 일을 진행시키면된다(물론 신입입장에서는 이 조차도 버거울 수 있다). 다시말해 시킨 일을 이상으로 오바하거나 다른 방안의 아이디어를 제안해서 이렇게 해야한다! 라고 주장하기보다는 일단 신뢰를 얻기 위해 리더가 예상한 만큼의 성과를 보여주면된다. 그렇게 신뢰를 쌓아올린다음 시킨 일 이상으로 오바해서 성과를 내는 모습을 보여주거나 서비스 아키텍쳐나 프로세스에 반대의견을 낸다면 더욱 설득력 있는 팀원이 될 수 있다. 그렇게 하다보면 완전 처음해보는일, 커리어에 완전 도움되는 일을 할 가능성이 커지고 나의 명셩도 올라가며 선순환이 발생할 여지가 생긴다.

특이 일정이 한달정도 소요되는 긴 프로젝트일 경우엔 프로젝트 진행 상황을 공유하면서 진행하 는것이 좋다. 아무말 하지않고 있다가 한달 뒤 짜잔~ 하면서 프로젝트를 오픈해도 좋지만 그다지 큰 신뢰를 쌓을 순 없다. 하지만 매주 리더에게 자신이 현재 어느 정도 수준으로 개발을 진행했는지 예정 일정대로 프로젝트를 마무리 할 수 있는지를 공유해주면 리더는 안심할 수 있고 프로젝트를 계속 믿고 맡겨 줄 것이다. 굳이 정식으로 진행상황을 보고할 필요는 없다. 커피타임에 넌지시 현재 진행상황이 어떻게 진행에 걸림돌이 되는 이슈는 이런이런 것들이 있다 라고 말해주는 수준이어도 충분히 리더는 안심할 수 있다.

## 신뢰받기 위해 한일
내 경우엔 직접적으로 리더에게 프로젝트 진행상황을 공유하지않고 나의 사수에게 진행상황을 공유하였다. 핑계를 대자면... 사수랑 같이 하는 일이기 때문에 리더에게만 공유한다면 사수는 프로젝트가 어떻게 돌아가는지 모른채 리더와 나의 대화로 될 가능성이 있기 때문이다. 또한 나의 사수는 리더에게 신뢰받는 입장이기 때문에 사수에게만 공유하여도 충분히 신뢰를 얻을 수 있을거라 판단하였다. 앞으로도 한 1년 ~ 2년간은 리더에게 직접 공유하기보다는 내 사수에게 먼저 공유하면서 점진적으로 리더에게 다가갈 생각이다.

# 담당 서비스의 애정
## 이 주제를 선택한 이유
그냥 쓰고 싶어서... 내가 맡은 서비스 자랑하고싶어서.

## 다음 검색 서비스
대학교때부터 '다음' 이미지 검색을 즐겨사용했다. 국내 출처의 이미지 검색은 다음이 제일 좋았다(네이버는 너무 교과서적인 이미지들만 결과로 내보내주더라). 그 이유는 인터넷 짤방같은 이미지를 내 의도와 맞게 잘 찾아주었기 때문이다. 이런 경험으로 이곳은 디테일하게 검색 니즈를 파악하여 개발은 하고 있을 것이다 라는 판단을 하였다.

하지만 그것은 나만의 생각이었고 직접 서비스를 담당하면서 기획자, 모델링 개발자, 검색엔진 개발자분들께 이야기를 듣다보니 인터넷 짤방 외 유저들의 다른 니즈가 있다는 사실을 알게되었다. 그 중엔 검색결과가 그다지 좋지않는 케이스들도 종종 있었다. 그래서 나는 기필코 다음 이미지 검색을 좋게 만드리라 다짐하고 이 서비스를 좋게 만들기 전까진 절대 조직이동이나 이직을 하지 않겠다 다짐했다. (물론 이동/이직할 수 있을진 모르겠지만 ㅎㅎ)

검색 품질을 좋게 하기위해 내가 할 수 있는 일들을 생각해보았는데 그 중 하나는 테스트 환경 구축이었다. 테스트 환경을 잘 구축하면 굳이 내게 요청하지 않아도 검색 모델링 개발자가 혼자서 여러 시도해볼 수 있기 때문에 이것저것 해보기 쉽고 좋은 아이디어가 나올 가능성이 커진다고 생각했다. 내가 맡은 구체적인 업무는 검색 시스템 운영개발자로 검색에 필요한 데이터 수집, 검색 API, 배포시스템을 주로 다룬다. 테스트 환경이 잘 갖춰지지 않은 상태에서 모델링 개발자가 이것저것 테스트를 해보기 위해서는 나에게 데이터 수집을 요청 해야하고 데이터를 가져갈 시점을 나에게 문의를 해야한다. 별거 아니라고 생각할 수 있지만 테스트 중 하나만 삐끗하더라도 모두 물거품이 되버리는 것이고 실수하면 일정이 연기된다는 부담감에 쉽사리 테스트를 진행하기 어려워진다. 그리하여 나에게 요청할 필요없이 모델링 개발자가 부담없이 테스트 할 수 있는 환경을 만들어주는 것이 내가 검색 서비스를 좋게 만들기 위한 일이라 생각했다. 

# 문서화와 코드의 동일시
## 이 주제를 선택한 이유
현재 내 상황에서는 개발작업과 문서작업을 동시에 하는 것은 불가능하기 때문에 업무시간에 개발을 하고 야근을 하면서 문서 작업을 하려했다. 하지만 역량발전을위한 개인시간 확보도 필요했기때문에 문서작업은 가장 낮은 우선순위에 들어가있고, 현재 1년째 backlog에 쌓여 있는 상태이다. 이러다가 backlog에서조차 drop될거같다는 생각이 들었다. 그러던 중 테스트 코드가 문서 역할을 대신할 수 있다는 이야기를 들었고 문서화를 최소화 하는 방향도 고려해야겠다는 생각들었다.

## 테스트코드를 문서처럼 작성해라.
주변 시니어 개발자분께 재밌는 이야기를 들었다. 이분의 지인분의 일화인데, 마이크로소프트는 입사하여 업무에 관련된 문서는 어디서 봐야하냐고 문의하자 test 코드에 다 있는데 무슨 문서를 찾냐 라고 한 것이다. 비니지스 로직의 내용이 문서로 존재하지 않고 test 코드에 다 정의되어있다니!?. 근데 나도 test코드를 만들면서 이 함수는 어떤 기능을 해야하는지 명확히하려 했던 것을 생각해보면 테스트 코드가 문서가 될 수 도 있겠다 생각들었다. 하지만 test코드를 문서처럼 만드는 일은 실제 행동에 옮기진 못했고 계속 염두만 하고 있는 부분이다. 굳이 바쁜 이 시점에서 문서화하기 위해 꾸역꾸역 테스트 코드를 만들 필욘 없기 때문이다. 추후 대규모의 신규 프로젝트를 할때 테스트 코드를 통해 문서화를 하면 좋을거같다 정도로만 생각하고 덮어놓게 된 주제다(그러고 보니 요즘 swagger라는 오픈소스를 활용하여 API 문서화를 쉽게 할 수 있다고 한다). 

## 문서를 작성한다면 간결히 작성하자.
아이폰은 제품의 가이드북이 없기로 유명하다. 그 이유는 스티븐잡스가 사용자들이 궁금하면 알아서 찾아볼 것이다 라고 판단하고 제품이 촌스러워지는(?) 가이드북을 제품 구성에서 뺐기 때문이다.

이러한 잡스의 생각이 문서 작성에서도 꽤 유용할 수 있다. 당신이 redis같은 인메모리 DB 서버 오픈소스를 만들었고 이에 대한 가이드 문서를 쓴다고 생각해보면 어느 수준에 맞춰 문서를 작성해야할지 감이 안올 수 있다. 예를 들면 pub/sub기능 문서를 작성하고 있는데 과연 pub/sub가 무엇인지, 어떨때 필요한지를 친절히 가이드 문서에 작성해줘야할까? 그 대답은 No이다. 대부분의 현업개발자들은 pub/sub 개념이 무엇이고 어떤 상황에서 사용하는 것이 적절한지 알고 있다. 공식 문서에서 교과서 처럼 `pub/sub은 queue에 job을 쌓아놓고 쓰레드가 job 가져가서 해당 작업을 처리하는 방식의 multi-thread worker 시스템에서 사용하면 좋다` 라고 적어둘 필요는 없다. 또한 너무 TMI로 가이드를 작성한다면 보는 이로 하여금 가독성이 떨어져 핵심을 캐치하기 힘들 수 있다. 따라서 문서를 작성할땐 적당히 지식이 있는 사용자를 예상 구독자로 가정하여 핵심만 간결이 딱딱 써주는 것이 좋다. 나아가 참고자료나 Appendix를 넣어준다면 지식이 없는 사람도 쉽게 찾아 볼 수 있어 매력적인 문서가 될 것이다.

이와 같이 개발문서도 너무 구체적으로 작성할 필요없이 핵심만 적어놓고 필요하다면 참고자료를 붙여 관리한다면 작성자의 입장에서도 쉽게쉽게 핵심만 써내려갈 수 있고 구독자가 문서를 볼때에도 쉽게 읽어볼 수 있다.

# 기본 전공지식의 필요도
갑을론박의 논란이 많은 주제이지만 그냥 내 관점대로 쓰겠다. 

입사 전까지만 해도 굳이 전산 전공을 하지 않더라도 누구나 개발을 할 수 있다고 생각하였다. 왜냐하면 오늘날 개발을 쉽게할 수 있는 오픈소스들이 많이 존재하고 누구나 가이드를 차근차근 따라가면 번뜩이는 아이디어로 재밌는 서비스를 충분히 만들어 볼 수 있기 때문이다. 이 이야기는 반은 맞고 반은 틀린말같다. 이렇게 말할 수 있는 이유는 어느 서비스, 어떤 포지션에서 개발을 하냐에 따라 맞을 수 도 있고 아닐수도 있기 때문에다. 

예를 들어 트래픽이 1TPS 이하의 서비스(암물한 서비스이다)를 개발하여 운영한다고 생각해보면 전산지식은 굳이 필요하지 않을것이다. 오픈소스 가이드에 나와있는 데모 코드만으로도 충분히 구현할 수 있기 때문이다. 하지만 1500TPS 이상의 서비스를 운영/개발 하기위해선 전공지식이 필수적이다. CPU 바운드의 서비스인지, IO 바운드의 서비스인지 파악하여 그에 적절한 선택을 해야하고 설정파일도 최적화를 시켜줘야하기 때문이다. 하지만 전공지식이 없더라도 비싼장비를 들여놓아 scale-up을 할 수 있다. 다만 전산 지식이 있다면 저렴한 장비로 분산 구성을 하여 높을 트랜잭션에서도 장애없는 서비스를 운영/게발 할 수 있다. 

그렇다면 무조건 전산지식이 있는 사람이 유리할까? 1500TPS를 감당하는 서비스지만 1건당 0.1원을 벌어오고, 1TPS 이하의 서비스지만 1건당 1000원을 벌어오는 서비스가 있다고 하자. 어떤 서비스를 만드는 개발자가 좋은 개발자일까? 굳이 전산 지식이 없고 장비를 비효율적으로 사용하더라도 사람들의 일상을 편리하게 만들어줄 수 있는 서비스를 만드는 개발자라면 충분히 가치있다고 볼 수 있다. 그렇다고 전산 지식만 있고 비지니스를 잘 모르는 개발자는 개발자가 아닐까? 그것도 아닐것이다. 좋은 서비스를 만들 수 있는 개발자가 있는 반면 이 서비스를 값싸게 제공해줄 수 있는 개발자도 필요할 것이다. 

그 이유 때문에 개발자에게 있어서 전산 지식은 필수라고 할 수 도 있고, 아닐수도 있는... 애매한 결론으로 마무리 짓는다(이것도 결국 많은 사람들이 네트워크를 형성하여 커뮤니케이션을 통해 서로의 전산지식을 공유하고, 또 서로의 번뜩이는 아이디어를 공유하는 선순환 생태계가 되면 굳이 언급할 필요없는 주제 일거같다).

# 마무리 하며...
2017-2018 회고록을 작성하면서 내 이야기를 주로 썼어야했는데 뭔가 젊은 꼰대(?)같이 개발은 이런거다, 개발은 이렇게 해야한다 라고 써둔거같다. 그래도 평소 다른 사람들에게 해주고 싶었던 의견들이고 이걸 글로 적어보니 내 나름대로 논리적이지 않은 의견들을 알 수 있었고 확실치 않았던 개념도 다시 한번 찾아보면서 확인해볼 수 있는 기회였다. 주저리주저리 많은 이야기를 했지만 이걸 모두 완독하는 사람이 있을진 모르겠다(나 조차도 긴글은 잘 안읽어서...). 어쩌다보니 해를 넘기는 회고록이 되었는데 그럼에도 안쓰는것보단 썼다는게 나에게 있어 크게 와닿았다. 또한 나의 이 github 페이지에 꾸준히 글을 포스팅할 수 있는 약간의 가능성은 보았다. 

지난 1년반동안 배운게 너무나 많았기 때문에 모든걸 다 쓸수 없다는게 아쉽지만 그래도 나름 중요하다고 생각한것들은 90%이상 남겼다고 자신한다. 그럼 이만 회고록을 마친다.


[IntroGit]: https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EA%B8%B0%EC%B4%88
[gitFlow]: https://nvie.com/posts/a-successful-git-branching-model/
[naverd2Nexon]: https://youtu.be/fHyTA-UIcqs?t=3513